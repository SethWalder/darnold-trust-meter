<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trust History | The Darnold Trust Meter</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Old+Standard+TT:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  
  <!-- Privacy-friendly analytics by Plausible -->
  <script async src="https://plausible.io/js/pa-cBZkQXvGt8fgr5RzFxD-v.js"></script>
  <script>
    window.plausible=window.plausible||function(){(plausible.q=plausible.q||[]).push(arguments)},plausible.init=plausible.init||function(i){plausible.o=i||{}};
    plausible.init()
  </script>
  
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <style>
    .time-filters {
      display: flex;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    .time-filter-btn {
      padding: 0.5rem 1rem;
      border: 1px solid #555;
      background: transparent;
      color: #555;
      font-family: 'Old Standard TT', serif;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .time-filter-btn:hover {
      background: #555;
      color: #f5f0e6;
    }
    .time-filter-btn.active {
      background: #1a1a1a;
      color: #f5f0e6;
      border-color: #1a1a1a;
    }
  </style>
</head>
<body>
  <div class="container">
    <header class="history-header">
      <a href="/" class="back-link">‚Üê Back to Trust Meter</a>
      <h1>Trust History</h1>
    </header>

    <main>
      <div class="chart-container">
        <div class="time-filters">
          <button class="time-filter-btn active" data-hours="superbowl">During Super Bowl</button>
          <button class="time-filter-btn" data-hours="1">Last 1 Hour</button>
          <button class="time-filter-btn" data-hours="4">Last 4 Hours</button>
          <button class="time-filter-btn" data-hours="24">Last 24 Hours</button>
        </div>
        <div class="chart-wrapper">
          <canvas id="historyChart"></canvas>
        </div>
      </div>
      
      <div class="meter-section" style="text-align: center;">
        <h2 style="font-family: 'Old Standard TT', serif; margin-bottom: 1rem; font-weight: 400;">Current Reading</h2>
        <div style="font-family: 'Old Standard TT', serif; font-size: 3rem; font-weight: 700;">
          <span id="current-trust">--</span>
        </div>
        <p style="color: var(--text-secondary); font-style: italic; margin-top: 0.5rem;">
          Based on <span id="total-votes">--</span> votes
        </p>
      </div>
    </main>

    <footer>
      <a href="/" class="history-link">Cast Your Vote</a>
    </footer>
  </div>

  <script>
    let chart = null;
    let allHistoryData = [];
    let currentFilter = 'superbowl'; // Default to During Super Bowl

    // Time intervals in minutes for each filter
    const timeIntervals = {
      superbowl: 1,  // During Super Bowl: every 1 minute
      1: 5,          // 1 hour view: every 5 minutes
      4: 10,         // 4 hour view: every 10 minutes
      24: 60         // 24 hour view: every hour
    };
    
    // Special time ranges for specific filters
    // Note: timestamps in DB are stored as UTC but represent ET times, so use Z suffix
    const specialStartTimes = {
      superbowl: new Date('2026-02-08T18:30:00Z') // 6:30 PM ET, Super Bowl kickoff
    };
    
    const specialEndTimes = {
      superbowl: new Date('2026-02-08T22:23:00Z') // 10:23 PM ET, end of Super Bowl
    };

    // Filter data based on time range
    function filterDataByHours(data, hours) {
      if (hours === 'all') return data;
      
      // Check for special time ranges (like superbowl with start AND end)
      if (specialStartTimes[hours]) {
        const startCutoff = specialStartTimes[hours];
        const endCutoff = specialEndTimes[hours];
        
        if (endCutoff) {
          // Filter between start and end
          return data.filter(d => {
            const timestamp = new Date(d.created_at);
            return timestamp >= startCutoff && timestamp <= endCutoff;
          });
        } else {
          // Just filter from start
          return data.filter(d => new Date(d.created_at) >= startCutoff);
        }
      }
      
      const now = new Date();
      const cutoff = new Date(now.getTime() - (hours * 60 * 60 * 1000));
      
      return data.filter(d => new Date(d.created_at) >= cutoff);
    }

    // Aggregate data into time buckets - show trust level as it was at the START of each bucket
    // allData = complete dataset, filteredData = what to display, intervalMinutes = bucket size
    function aggregateByTimeInterval(allData, filteredData, intervalMinutes, hours) {
      if (filteredData.length === 0) return [];
      
      const intervalMs = intervalMinutes * 60 * 1000;
      
      // Sort all data by time
      const sortedAllData = [...allData].sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
      
      // Find all unique bucket times from the filtered data
      const bucketSet = new Set();
      filteredData.forEach(d => {
        const timestamp = new Date(d.created_at).getTime();
        const bucketTime = Math.floor(timestamp / intervalMs) * intervalMs;
        bucketSet.add(bucketTime);
      });
      
      const bucketTimes = Array.from(bucketSet).sort((a, b) => a - b);
      if (bucketTimes.length === 0) return [];
      
      // For each bucket, find the trust level from ALL data as it was at the START of that bucket
      const result = [];
      
      for (let i = 0; i < bucketTimes.length; i++) {
        const bucketStart = bucketTimes[i];
        
        // Find the last snapshot at or before this bucket start time from ALL data
        let trustLevel = null;
        for (let j = sortedAllData.length - 1; j >= 0; j--) {
          const snapshotTime = new Date(sortedAllData[j].created_at).getTime();
          if (snapshotTime <= bucketStart) {
            trustLevel = sortedAllData[j].trust_level;
            break;
          }
        }
        
        // If no snapshot found at or before bucket start (shouldn't happen with all data),
        // use the first available snapshot
        if (trustLevel === null && sortedAllData.length > 0) {
          trustLevel = sortedAllData[0].trust_level;
        }
        
        if (trustLevel !== null) {
          result.push({
            created_at: new Date(bucketStart).toISOString(),
            trust_level: trustLevel
          });
        }
      }
      
      // Now fill in gaps between buckets
      if (result.length === 0) return [];
      
      const firstBucket = new Date(result[0].created_at).getTime();
      const lastBucket = new Date(result[result.length - 1].created_at).getTime();
      
      const completeResult = [];
      let resultIndex = 0;
      let previousTrustLevel = result[0].trust_level;
      
      for (let bucketTime = firstBucket; bucketTime <= lastBucket; bucketTime += intervalMs) {
        // Check if we have actual data for this bucket
        if (resultIndex < result.length && new Date(result[resultIndex].created_at).getTime() === bucketTime) {
          previousTrustLevel = result[resultIndex].trust_level;
          resultIndex++;
        }
        
        completeResult.push({
          created_at: new Date(bucketTime).toISOString(),
          trust_level: previousTrustLevel
        });
      }
      
      return completeResult;
    }

    // Process data: filter by time range for display, but use all data to determine trust levels
    function processData(data, hours) {
      const filtered = filterDataByHours(data, hours);
      const interval = timeIntervals[hours] || timeIntervals.all;
      return aggregateByTimeInterval(data, filtered, interval, hours);
    }

    // Filters that should hide dots on the chart
    const hideDotsFilters = ['superbowl'];
    
    // Update chart with processed data
    function updateChart(processedData) {
      if (chart) {
        // Set x-axis bounds for superbowl filter (fixed start and end times)
        if (currentFilter === 'superbowl') {
          chart.options.scales.x.min = specialStartTimes.superbowl;
          chart.options.scales.x.max = specialEndTimes.superbowl;
        } else {
          // Auto-determine range for other filters
          chart.options.scales.x.min = undefined;
          chart.options.scales.x.max = undefined;
        }
        
        if (processedData.length < 1) {
          // Clear the chart when no data
          chart.data.labels = [];
          chart.data.datasets[0].data = [];
          chart.update();
          return;
        }
        
        const labels = processedData.map(d => new Date(d.created_at));
        const values = processedData.map(d => d.trust_level);
        
        chart.data.labels = labels;
        chart.data.datasets[0].data = values;
        // Hide or show dots based on current filter
        const hideDots = hideDotsFilters.includes(currentFilter);
        chart.data.datasets[0].pointRadius = hideDots ? 0 : 3;
        chart.data.datasets[0].pointHoverRadius = hideDots ? 0 : 5;
        chart.update();
      }
    }

    async function loadHistory() {
      try {
        // Fetch history data
        const historyResponse = await fetch('/api/history');
        allHistoryData = await historyResponse.json();
        
        // Fetch current trust level
        const trustResponse = await fetch('/api/trust');
        const trustData = await trustResponse.json();
        
        // Update current stats
        document.getElementById('current-trust').textContent = Math.round(trustData.trustLevel) + '%';
        document.getElementById('total-votes').textContent = trustData.totalClicks;
        
        // Process and display data
        const processedData = processData(allHistoryData, currentFilter);
        
        if (processedData.length < 1) {
          return;
        }
        
        // Prepare chart data
        const labels = processedData.map(d => new Date(d.created_at));
        const values = processedData.map(d => d.trust_level);
        
        // Create gradient
        const ctx = document.getElementById('historyChart').getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, 0, 400);
        gradient.addColorStop(0, 'rgba(196, 30, 58, 0.2)');
        gradient.addColorStop(0.5, 'rgba(180, 180, 180, 0.1)');
        gradient.addColorStop(1, 'rgba(95, 168, 211, 0.2)');
        
        // Check if dots should be hidden for current filter
        const hideDots = hideDotsFilters.includes(currentFilter);
        
        // Create or update chart
        if (chart) {
          chart.data.labels = labels;
          chart.data.datasets[0].data = values;
          chart.update();
        } else {
          chart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [{
                label: 'Trust Level',
                data: values,
                borderColor: '#1a1a1a',
                backgroundColor: gradient,
                borderWidth: 2,
                fill: true,
                tension: 0.3,
                pointRadius: hideDots ? 0 : 3,
                pointBackgroundColor: '#1a1a1a',
                pointBorderColor: '#f5f0e6',
                pointBorderWidth: 2,
                pointHoverRadius: hideDots ? 0 : 5
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  display: false
                },
                tooltip: {
                  backgroundColor: '#1a1a1a',
                  titleColor: '#f5f0e6',
                  bodyColor: '#f5f0e6',
                  borderColor: '#333',
                  borderWidth: 1,
                  padding: 12,
                  displayColors: false,
                  titleFont: {
                    family: "'Old Standard TT', serif"
                  },
                  bodyFont: {
                    family: "'Libre Baskerville', serif"
                  },
                  callbacks: {
                    title: function(context) {
                      const date = new Date(context[0].parsed.x);
                      return date.toLocaleString();
                    },
                    label: function(context) {
                      return 'Trust Level: ' + Math.round(context.raw) + '%';
                    }
                  }
                }
              },
              scales: {
                x: {
                  type: 'time',
                  time: {
                    displayFormats: {
                      hour: 'MMM d, ha',
                      day: 'MMM d'
                    }
                  },
                  grid: {
                    color: 'rgba(0, 0, 0, 0.08)',
                    drawBorder: false
                  },
                  ticks: {
                    color: '#555',
                    font: {
                      family: "'Libre Baskerville', serif",
                      size: 11
                    }
                  }
                },
                y: {
                  min: 0,
                  max: 100,
                  grid: {
                    color: 'rgba(0, 0, 0, 0.08)',
                    drawBorder: false
                  },
                  ticks: {
                    color: '#555',
                    font: {
                      family: "'Libre Baskerville', serif",
                      size: 11
                    },
                    callback: function(value) {
                      return value + '%';
                    }
                  }
                }
              },
              interaction: {
                intersect: false,
                mode: 'index'
              }
            }
          });
        }
      } catch (error) {
        console.error('Failed to load history:', error);
      }
    }

    // Set up filter button click handlers
    document.querySelectorAll('.time-filter-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        // Update active state
        document.querySelectorAll('.time-filter-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        // Get filter value (handle special string filters like 'superbowl')
        const hours = this.dataset.hours;
        if (hours === 'superbowl') {
          currentFilter = hours;
        } else {
          currentFilter = parseInt(hours);
        }
        
        // Process and update chart
        const processedData = processData(allHistoryData, currentFilter);
        updateChart(processedData);
      });
    });

    // Load on page load
    loadHistory();
    
    // Refresh every 30 seconds
    setInterval(loadHistory, 30000);
  </script>
</body>
</html>
